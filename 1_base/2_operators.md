# Тема: Базовые операторы, логические операторы.

Тайминг: 1 час 30 минут (90 минут)

## Дорожная карта занятия

* [Базовые операторы](#base_operators)
    * [Термины](#base_termins)
    * [Математические операторы](#math_operators)
    * [Конкатенация строк](#concat_string)
    * [Приведение к числу](#to_number)
    * [Приоритет операторов](#operators_priority)
    * [Инкременты и декременты](#increment_decrement)
    * [Сокращенное присваивание с вычислениями](#short_assignment)
* [Логические операторы](#boolean_operators)
    * [Основы](#boolean_base)
    * [Операторы сравнения](#compare_operators)
    * [Сравнение строк](#compare_string)
    * [Сравнение разных типов](#compare_any)
    * [Строгое и не строгое сравнение](#strict_compare)
    * [Операторы `||` и `&&`](#logic_operators)
    * [Оператор отрицания `!` и двойного отрицания `!!`](#negation_operator)
    * [Оператор нулевого слияния `??`](#null_merge_operator)
* [Итого](#result)
* [Тренировка](#trains)
* [Домашнее задание](#homework)
* [Дополнительный материал](#learn)

## <a id="base_operators">Базовые операторы</a>

В JavaScript, также, как и в любом другом языке программирование существуют операторы для совершения математических
операций,
склеивания строк, а также дополнительные, упрощающие работу с числами, массивами, объектами.

Рассмотри эти операторы в данной главе.

### <a id="base_termins">Термины</a>

Далее, в этой главе будут использоваться определенные термины, поэтому, чтобы они не казались чем-то непонятным,
ознакомимся с ними:

#### - Операнд

Операнд - это то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а
правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».

#### - Унарный оператор

Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус`-` меняет знак
числа на противоположный:

```javascript
let x = 1;

x = -x;
alert(x); // -1, применили унарный минус
```

#### - Бинарный оператор

Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

```javascript
let x = 1, y = 3;
alert(y - x); // 2, бинарный минус вычитает значения
```

Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания
(унарный оператор, который обращает знак), и оператор вычитания (бинарный оператор, который вычитает одно число из
другого).

Рассмотрим еще несколько примеров с оператором `+`:

[//]: # (TODO)

### <a id="math_operators">Математические операторы</a>

В `JS` поддерживаются следующие математические операторы:

- Сложение `+`
- Вычитание `-`;
- Умножение `*`;
- Деление `/`;
- Взятие остатка от деления `%`;
- Возведение в степень `**`;

Первые четыре оператора очевидны, а про `%` и `**` стоит сказать несколько слов.

#### Оператор взятия остатка от деления `%`

Бывают случаи, когда для решения задачи, нам необходимо получить остаток от деления, например для вычисления
четных/нечетных чисел.

У каждого нечетного числа остаток от деления на 2 будет 1.

```javascript
const result = 3 % 2
```

В данном примере, в переменную `result` будет записан целочисленный остаток от деления 3 на 2.
В итоге будет записана 1.

[//]: # (Как это работает?)

[//]: # ()

[//]: # (Оператор `%` делит операнд слева на операнд справа до тех пор, пока не получится разделить левый операнд на правый,)

[//]: # (получив целочисленное значение. Остаток, который получится в результате такой операции и будет остатком от деления.)

[//]: # (То есть: Делим 3 на 2 - получаем 1.5. Вычитаем из 3 результат выражения 1 * 2 и получаем остаток от деления.)

#### Возведением числа в степень `**`

В JavaScript существует оператор для возведения чисел в степень - это `**`.

Синтаксис следующий:

```javascript
const a = 2 ** 3; // 8
const b = 5 ** 2; // 25
const c = 5 ** 3; // 125
```

### <a id="concat_string">Конкатенация строк</a>

Конкатенация строк - это специальный механизм, который позволяет нам склеивать строки в одну, например:

```javascript
const name = 'Василий';
const surname = 'Иванов';
const patronymic = 'Петрович';

const fio = surname + ' ' + name + ' ' + patronymic; // "Иванов Василий Петрович" 
```

В данном примере, у нас есть 3 переменных: `name`, `surname`, `patronymic`. Каждая из этих переменных содержит часть ФИО
пользователя. Имея эти переменные, мы можем динамично склеить их в одну строку и получить ФИО в отдельную переменную.
Константа `fio` как раз таки и будет хранить в себе ФИО пользователя, где каждое слово будет разделено пробелам `" "`.
Оператор `+`, применяющийся к строкам будет производить их склеивание. Этот механизм и называется **конкатенацией**.

### <a id="string_template">Шаблонная строка</a>

В предыдущем примере, мы наглядно увидели как из нескольких строковых значений получить общую строку. Вышеупомянутый
способ
не совсем удобный и к нам на помощь приходит такой инструмент, как **шаблонная строка**.

```javascript
const name = 'Василий';
const surname = 'Иванов';
const patronymic = 'Петрович';

const fio = `${name} ${surname} ${patronymic}`;
```

В данном примере мы создаем строку не привычными нам кавычками (двойными или одинарными), а **обратными кавычками**.
В строке, созданной с помощью обратных кавычек, мы можем вставлять абсолютно **любое JavaScript выражение** - будь то
переменной,
или математической операцией (сложение/вычитание/ и т.д.).
Так же, стоит упомянуть и о том, что перенос строки в такой строке будет сохраняться, что позволяет нам писать не только
шаблонные строковые значения, но еще и **многострочные**.

### <a id="to_number">Приведение к числу</a>

В [предыдущей статье]() мы рассматривали возможность приведения типов данных в JS. Сейчас, остановимся по подробнее на
приведении строки к числ, для этого нам понадобится оператор "унарный `+`".

> Напомню, что **унарным** считается оператор, применяющийся к одному операнду.
> Унарный `+` ничего не делает с числами, но, если операнд является НЕ числом, то JS попытается преобразовать его в
> число.
>
> **Операнд** - это значение, к которому применяется оператор.
>
> [Подсказка](#base_termins)

Синтаксис:

```javascript
const a = '1';
const b = +a;

console.log(a); // '1';
console.log(b); // 1
console.log(a === b); //false
```

На самом деле, это то же самое, что и `Number(...)`, только короче.

**Важное примечание** - унарный `+` имеет более высокий приоритет, чем бинарный, поэтому если они оба будут стоять
в одном выражении, сначала выполнится унарный, затем бинарный, например:

```javascript
const a = '1';
const b = '22';
const c = +a + +b
```

В данном примере `+a` и `+b` будут выполнены до того, как произойдет сложение `a` и `b`.

Аналогичная запись:

```javascript
const a = '1';
const b = '22';
const c = Number(a) + Number(b)
```

В обоих примерах, мы сначала приведем строки `a` и `b` к числу, затем сложим их.
Стоит помнить, что если в любой из строк, приводимой к числу будет содержаться какой-либо текст, то результат приведения
такой строки к числу вернет нам `NaN`(not a number).
Для проверки числа на `NaN` существует специальная утилита `isNaN`. Она возвращает `true/false` значение, в зависимости
от
того, является ли значение `NaN` или нет.

Например:

```javascript
const name = 'Андрей';
const num = Number(name) // NaN
console.log(isNaN(num)) // true
```

### <a id="operators_priority">Приоритет операторов</a>

Про приоритет операторов детально и подробно, мы разговаривать не будем, так как нет острой необходимости запоминать их
все.
На данный момент стоит запомнить лишь то, что унарный оператор имеет более высокий приоритет, чем бинарный.

Подробная статья на MDN
про [приоритет операторов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
для самостоятельного ознакомления.

### <a id="increment_decrement">Инкременты и декременты</a>

В будущем, мы очень много будем работать с инкрементами и декрементами, поэтому стоит запомнить что это, зачем оно нужно
и как работает.

#### Инкремент `++`

Допустим, у нас есть число `n` и нам нужно увеличить его на единицу. Как это сделать?
Первый способ, который приходит на ум, это просто прибавить единицу.

```javascript
let n = 22;
n = n + 1;
```

Но, выглядит это не очень красиво, к тому же не профессионально. Для таких операций в JS существуют инкременты.

```javascript
let n = 22;
n++; // 23
```

Результат работы двух этих примеров, будет абсолютно одинаковый.

#### Декремент `--`

Аналогично тому, что нам понадобится увеличивать число на единицу, нам может понадобиться и уменьшение числа.

```javascript
let n = 22;
n--; // 21
```

Декремент - это то же самое, что и инкремент, только на уменьшение значения.

#### Постфиксная и префиксная форма

Любой из операторов инкремент/декремент поддерживает 2 формы написания выражения - это постфиксная и префиксная.
Разница между ними в том, что в постфиксной форме мы указываем `++` или `--` после переменной, а в префиксной перед.

```javascript
let n = 22;

++n; //Префиксная форма инкремента
n++; //Постфиксная форма инкремента

--n; //Префиксная форма декремента
n--; //Постфиксная форма декремента
```

Еще одно **важное** отличие между пре и пост-фиксными формами операторов - возвращаемое значение операции.

Префиксная форма, сначала выполняет операцию, затем возвращает значение. Постфиксная - наоборот, сначала возвращает
значение,
а затем выполняет операцию.

```javascript
let a = 22;

let m = ++a // Выполнится сложение, а затем в переменную m будет записано значение 23, значение a так же изменится на 23.

let b = 22;

let k = b++ // Будет записано значение 22, а затем выполнится сложение, значение в b будет 23.
```

Аналогично работает и с декрементами:

```javascript
let a = 22;

let m = --a; // Сначала выполнится вычитание, затем вернется значение 21, в переменную a запишется 21

let b = 22;

let k = b-- // Сначала вернется значение 22, затем выполнится вычитание и в переменную b присвоится значение 21
```

> ### Важно!
> Инкремент/декремент можно использовать только для переменной!
> Если попытаться написать `5++`, то вы получите ошибку.

#### Итого:

- Если вы используете возвращаемое значение инкремента/декремента - стоит уделить внимание тому, какую форму пост/пре
  использовать, чтобы реализовать корректную логику.
- Если значение не используется, то разницы в пост/пре - нет.
- Если вы хотите использовать возвращаемое значение сразу "на месте", то используйте префиксную форму
  инкремента/декремента.
- Инкремент/декремент можно использовать в любых выражениях.

### <a id="short_assignment">Сокращенное присваивание с вычислениями</a>

Зачастую, бывают случаи, когда нам нужно применить оператор к переменной и сохранить в ней же получившийся результат.
Для таких задач, существует сокращенный синтаксис выполнения арифметических операций с присваиванием:

```javascript
let a = 22
a *= 2 //Умножнаем текущей значение переменной a на 2
a += 10 //Добавляем к текущему значению переменной a число 10
a -= 10 //Вычитаем из текущего значения переменной a число 10
a /= 10 // Делим текущее значение переменной a на 10

//При этом можно вместо выполнения операций с одним конкретным числом, можно указать выражение

a += 10 * 2 //Сначала выполнится умножение 10 на 2, 
// затем результат этого выражения будет прибавлен к текущему значению переменной a
```

Подобные краткие записи существуют для всех математических операторов.

## <a id="boolean_operators">Логические операторы</a>

В JavaScript существуют следующие операторы сравнения:

- `>=` - больше или равно;
- `<=` - меньше или равно;
- `==` - не строго равно;
- `===`- строго равно;
- `>` - строго больше;
- `<` - строго меньше;
- `!=` - не строго, не равно;
- `!==` строго не равно.

Так же существуют и логические операторы:

- `||` - логическое ИЛИ;
- `&&` - логической И;
- `!` - оператор отрицания (НЕ);
- `!!` - оператор приведения к `boolean` (двойное НЕ);
- `??` - оператор нулевого слияния.

Про логические операторы мы поговорим в самом конце этой главы, сейчас уделим время операторам сравнения.

В этом разделе мы познакомимся с ними, рассмотрим примеры использования и узнаем тонкости работы с этими операторами.

> Раздел содержит нюансы, которые спрашивают на интервью от **junior** до **middle** позиций, а иногда даже и на senior,
> поэтому стоит отнестись к изучению материала с максимальной внимательностью.

### <a id="boolean_base">Основы</a>

В JavaScript результат любого сравнения имеет логический тип: `true/false`.
Так же и в реальной жизни, одно значение либо больше, либо меньше другого. Либо равно, либо не равно и т.д.

- `true` - означает, что результат сравнения оказался правдивым
- `false` - означает, что результат сравнения оказался НЕ правдивым.

Как и любое другое значение, результат сравнения `boolean` можно присвоить в переменную, либо же использовать,
в круглых скобках, при построении условий `if/else if`.

### <a id="compare_operators">Операторы сравнения</a>

Как мы уже обсуждали ранее, операторы сравнения возвращают нам `boolean` значение, которое мы можем присвоить в
переменную.

Например:

```javascript
const a = 22;
const b = 33;

if (a > b) {
    console.log('Значение переменной a больше, чем значение переменной b')
} else {
    console.log('Значение переменной a меньше или равно значению переменной b')
}
```

В данном примере, если значение переменной `a` будет больше, чем значение переменной `b`, то условие `a > b`
вернет `true` и выполнится блок кода `if`, а иначе - будет выполнен блок кода `else`.

В таких сравнениях мы можем использовать следующие операторы: `>`, `<`, `>=`, `<=`, `==`, `===`, `!=`, `!==`.
Все зависит от задачи, которую нам нужно решить.

Рассмотрим еще один пример.

Допустим, нам нужно решить задачку: Есть корзина товаров, в которую пользователь добавил какие-то товары, мы посчитали
сумму всех товаров и получили это значение в переменную `sum`. Необходимо применить скидку на сумму товаров. Если сумма
товаров более или равно 20.000 рублей, то применить скидку 10%, если больше или равно 65.000 рублей, то 15%, если более
или равно 100.000, то 20%.

```javascript
const sum = 39_730; // У нас есть сумма товаров в корзине, к примеру это 39.730 руб.
let result = sum; // Создаем изменяемую переменную result, куда изначально присваиваем значение суммы корзины

// Изначально присваиваем sum в result для того, чтобы если не выполнится ни одно условие в result была записана сумма корзины 

//Если сумма больше или равно 20.000 и меньше 65.000
if (sum >= 20_000 && sum < 65_000) {
    //Применяем скидку 10%
    result -= sum * 0.10

    //Если сумма больше или равно 65.000 и меньше 100.000
} else if (sum >= 65_000 && sum < 100_000) {
    //Применяем скидку 15%
    result -= sum * 0.15

    //Если сумма товаров более или равно 100.000
} else if (sum >= 100_000) {
    //Применяем скидку 20%
    result -= sum * 0.2
}

//В данном кейсе будет применена скидка 15% и мы получим итоговую сумму: 35_757 руб.
//Т.к. применится скидка в 10%
console.log(result)
```

В примерах мы использовали логический оператор `&&` (логическое И), работу которого мы рассмотрим
немного [позже](#logic_operators).

### <a id="compare_string">Сравнение строк</a>

Если числа сравниваются по значение, то строки сравниваются немного по-другому. Рассмотрим как это работает.

Для определения какая строка из двух больше - JavaScript сравнивает не длины этих строк, а "алфавитный порядок", проще
говоря строка сравнивается не по длине, а по символам.

**Алгоритм сравнения двух строк довольно прост:**

1. Сначала сравниваются первые символы строк.
2. Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй.
   Сравнение завершено.
3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
4. Сравнение продолжается, пока не закончится одна из строк.
5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.

Рассмотрим примеры:

```javascript
console.log('Я' > 'А') // true
console.log('Консоль' > 'Конец') // true
console.log('Оператор' > 'Операнд') // true
```

В примерах выше, сравнение `Я > А` закончится сразу же, т.к. `Я` по алфавиту больше, чем `А`.
Второй пример `Консоль > Конец`, немного интереснее:

- `К` равно `К`
- `о` равно `о`
- `н` равно `н`
- `c` больше, чем `о`, на этом сравнение заканчивается. Строка `Консоль` больше, чем `Конец`.

> #### Используется кодировка Unicode, а не настоящий алфавит
> Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть
> и различия.
>
> Например, в JavaScript имеет значение регистр символов. Заглавная буква "A" не равна строчной "a". Какая же из них
> больше? Строчная "a". Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую
> использует JavaScript (Unicode)

### <a id="compare_any">Сравнение разных типов</a>

Важная особенность JavaScript - при сравнении разных типов данных в одном выражении, будет выполнено приведение этих
значений к числу.

```javascript
console.log('2' > 1) //true, так как '2' будет приведено к числу
console.log('22' > 21) // true, так как '22' будет приведено к числу
console.log('13' > 100) // false, так как '13' будет приведено к числу 
```

Если в сравнении будет участвовать `boolean` значение, то `true` будет приведено к `1`, а `false` к `0`.

### <a id="strict_compare">Строгое и не строгое сравнение</a>

Есть важное отличие между операторами `==`(не строгое сравнение) и `===` (строгое сравнение).
Это отличие заключается в том, что оператор не строгого сравнения `==`, если оба операнда разных типов данных,
попытается привести их к одному и после этого сравнит между собой приведенные значения в одном типе данных.

В то время как строгое сравнение `===` сначала проверит типы данных двух значений, и, если, эти типы равны, сравнит их
значения, а если типы оказались не равны, то вернет `false` сразу.

Исходя из практики работы с представленными операторами сравнения `==` и `===`, в 99% случаев следует использовать
оператор строгого сравнения `===`, чтобы
избежать [неявного приведения типов](https://github.com/Mistrade/mistrade_basic_js_course/blob/operators/1_into/1_what_is_js.md#change_data_type_variants)
и получить корректный результат.

### <a id="logic_operators">Операторы `||` и `&&`</a>

Операторы `||` и `&&` обычно используются для объединения нескольких условий в одно.
Ранее мы рассматривали задачу, где нам нужно было применить скидку на сумму товаров в корзине, в зависимости от того, на
какую сумму пользователь набрал товаров в корзину.

#### Логическое (И) `&&`

Данный оператор вернет `true` только тогда, когда оба операнда (и слева, и справа) будут равны `true`.

Рассмотрим наглядный пример:

```javascript
console.log(true && true) // true
console.log(false && true) // false
console.log(false && false) // false
console.log(true && false) // false
```

Как мы видим по данному, примеру, если хотябы один из операндов будет равен `false`, то оператор `&&` вернет `false`.

> Оператор `&&` находит первое ложное значение.
> Если операнды требуют приведения к `boolean`, то оператор `&&` будет вычислять их значения и приводить операндны
> к `boolean` слева направо, по ходу сравнения.
> Затем происходит поиск `false` значений. Как только оно будет найдено, оператор `&&` вернет сразу же это ложное
> значение.
> Если `false` не был найден, как в примере `console.log(true && true)`, то оператор `&&` вернет последнее значение из
> всех операндов.

```javascript
const a = 22;
const b = 12;
const c = 39;

const checkResult = a && b && c // 39
```

В данном примере, мы видим, что переменная `checkResult` получит значение 39, так как все значения `a`, `b`, `c` при
приведении к `boolean` будут `true`, соответственно оператор `&&` возвращает последнее значение справа, если не найдено
ни одного `false`-приводимого значения.
см. [Значения, которые всегда будут `false`](https://github.com/Mistrade/mistrade_basic_js_course/blob/operators/1_into/1_what_is_js.md#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

```javascript
console.log(22 && null && 39) //null
console.log("" && 127 && true) // ""
```

В примерах выше, мы видим, что оператор `&&` возвращает первое найденное `false`-приводимое значение.
В первом `console.log()` - это `null`, а во втором - `""`(пустая строка).
см. [Значения, которые всегда будут `false`](https://github.com/Mistrade/mistrade_basic_js_course/blob/operators/1_into/1_what_is_js.md#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

#### Логическое (ИЛИ) `||`

Существует еще один логический оператор, **похожий на логическое (И) `&&`**, но работает он `||` немного иначе.

Оператор `||`, в отличии от `&&`, возвращает не первое найдено `false`-приводимое значение или последнее, если таких не
найдено, а первое `true` приводимое значение.

Таким образом, мы можем выстраивать логические цепочки, перечисляя несколько значений с помощью оператора `||` получим:

- Либо первое истинное (`true`-приводимое) значение
- Либо последнее значение, если `true`-приводимые не были найдены.

Примеры:

```javascript
console.log(22 || false) // 22
console.log(false || null || "" || true) // true
console.log(NaN || 0 || 12) // 12
```

см. [Значения, которые всегда будут `false`](https://github.com/Mistrade/mistrade_basic_js_course/blob/operators/1_into/1_what_is_js.md#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

С помощью оператора `||` мы можем обрабатывать отсутствие данных:

```javascript
const a = null;
const b = a || 'default' // b
```

Если в перемнной `a` будет `false`-приводимое значение, то по умолчанию, мы установим в переменную `b`
значение `"default"`.

#### Операндами могут быть как значения, так и выражения

С помощью операторов `||` и `&&` можно сранивать не только готовые значения, но и выражения:

```javascript
console.log(false || (2 + 2) || (true + 1) || (false + 22)) // 4, так как 2+2 = 4 
console.log((2 + 2) && (false + 1) && NaN) // NaN, так 2+2 = 4, false + 1 = 1, NaN - falsy значение. 
```

### <a id="negation_operator">Оператор отрицания `!` и двойного отрицания `!!`</a>

Оператор отрицания в JavaScript - это `!` (восклицательный знак).

```javascript
const a = !true // false
```

Оператор применяется перед операндом (слева) и работает следующим образом:

- Приводит значение операнда к логическому типу: `Boolean(value)`;
- Возвращает противоположное значение.

Так же, в JavaScript есть оператор двойного отрицания `!!`, который приводит значение к логическому типу, являясь
альтернативой `Boolean(value)`. По сути, происходит следующее:

- Приведение значения к логическому типу
- Первый `!` возвращает противоположное значение
- Второй `!` возвращает противоположное значение от противоположного значения.

Приоритет операторов отрицания - наивысший. Любой из них выполнится раньше, чем `||` или `&&`.

### <a id="null_merge_operator">Оператор нулевого слияния `??`</a>

Еще одним интересным операторов является оператор нулевого слияния `??`.

> #### Важное примечание
> Вопросы про данный оператор задаются на технических интервью на позиции `junior` и `middle`.
> Стоит отнестись с пристальным вниманием к тому, чтобы понять как работает данный оператор. Удачи!
>
> Буквально недавно, была ситуация, когда кандидат на позицию `middle` провалил интервью, не ответив на вопрос о работе
> данного оператора.
> Пугаться не стоит, в нем нет ничего сложного, просто это относительно недавный оператор, о котором знают еще не все.
>
> Мы ведь не хотим попасть в число этих людей?))

> #### Еще одно важное примечание
> Поскольку данный оператор был добавлен в язык относительно недавно, то могут возникнуть проблемы при работе с ним,
> поскольку старые браузеры не умеют работать с ним.
>
> Это также может быть одним из вопросов на технических интервью.

Приступим к оператору нулевого слияния. Данный оператор обрабатывает значения `null` и `undefined`, возвращая операнд
слева, если он не является `null` или `undefined` или операнд справа в противном случае.

Для данного значения, введем новый термин `определенное значение` - это значение, которое не
является `null`/`undefined`.

```javascript
const a = null;
const b = 90;
console.log(a ?? b)
```

Рассмотрим поэтапно, как работает оператор `??` в кейсе `a ?? b`:

1. Оператор проверяет значение `а` на **определенность** и, если значение переменной `a` определено (строго не
   равно `null` или `undefined`), будет возвращено значение `a`.
2. В случае, если `a` - не определно (строго равно `null` или `undefined`), будет возвращено значение `b`.

**Проще говоря**, оператор `??` возвращает левый операнд в случае, если его значение не `null` или `undefined`, а иначе
операнд справа.

Данный оператор не является чем-то принципиально новым. Он лишь упрощает работу в случаях, когда нужно получить
"определенное" значение (строго не равное `null`/`undefined`).

Если попытаться реализовать подобную логику без использования оператора нулевого слияния `??`, то получится вот такой
способ:

```javascript
const a = null;
const b = 90

if (a !== null && a !== undefined) {
    console.log(a)
} else {
    console.log(b)
}
```

Как правило, оператор `??` нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой
переменной.

Ранее, мы рассматривали, как с помощью оператора "логическое (ИЛИ) `||`" задать значение по умолчанию для переменной,
выглядело это следующим образом:

```javascript
const a = "";
const b = a || 'Не определено' // будет "Не определено", так как "" - это falsy значение.
```

Обратите внимание, что оператор `||` проверяет `falsy` значение и возвращает первое значение, которое можно привести
к `true`.
Однако, оператор `??` работает иначе - он проверяет "определено" значение переменной или нет.

В данном примере, если вместо `||` использовать `??`, то в переменную `b` будет присвоено значение `""`, так как это
значение строго не равно ни `null`, ни `undefined`.

```javascript
const a = "";
const b = a ?? "Не определено" // будет "" (пустая строка), так как значение a не равно ни null, ни undefined.
```

Проще говоря:

- Оператор `||` возвращает первое **истинное** `truthy` значение, иначе последнее.
- Оператор `??` возвращает первое **определенное** значение, иначе последнее.

#### Использование `??` вместе с `||` и `&&`.

Использование `??` совместно с `||` и/или `&&` в одном выражении запрещено по соображениям безопасности, чтобы избежать
проблема перехода с `||` на `??`.

```javascript
let x = 1 && 2 ?? 3; // Синтаксическая ошибка
```

Используйте скобки, чтобы обойти это ограничение:

```javascript
let x = (1 && 2) ?? 3; // Работает без ошибок
```

## <a id="result">Итого</a>

- Узнали что такое [Операнд, унарный и бинарный оператор](#base_termins)
- Мы ознакомились с [математическими операторами](#math_operators): `+`, `-`, `/`, `*`, `%`, `**`.
- [Конкатенация строк](#concat_string) - это процесс склеивания нескольких строковых значений в одну единую строку.
- Чтобы увеличить или уменьшить значение числовой переменной на 1 существуют [инкременты/декременты](#increment_decrement).
- При [сравнении любого типа данных](#compare_any) с числом, оба операнда будут приведены к числу.
- Узнали про [операторы сравнения](#compare_operators): `>`, `<`, `>=`, `<=`, `==`, `===`, `!=`, `!==`.
- Результат сравнения возвращает `boolean` значение.
- Строки сравниваются [по символьно](#compare_string) в кодировке Unicode.
- Символы в нижнем регистре имеют наибольший приоритет, относительно символов в верхнем регистре.
- Оператор [не строгого сравнения](#strict_compare) `==` неявно приведет значения операндов к одному типу.
- Оператор [строгого сравнения](#strict_compare) сравнивает и тип данных, и значение. Если одна из проверок вернет `false`, результат
  сравнения будет также `false`.
- Оператор ["Логическое (И) `&&`"](#logic_operators) возвращает первое найденное `falsy` значение, либо последнее, если `falsy` значения
  не найдены.
- Оператор ["Логическое (ИЛИ) `||`"](#logic_operators) возвращает первое найденное `thruthy` значение, либо последнее, если `thruthy`
  значения не найдены.
- Чтобы привести значение переменной к `boolean` можно использовать [оператор двойного отрицания](#negation_operator) `!!`.
- [Оператор отрицания](#negation_operator) приводит значение к `boolean` и возвращает противоположное значение.
- [Оператор нулевого слияния](#null_merge_operator) `??` возвращает левый операнд, если он строго не равен `null` или `undefined` и правый,
  если левый строго равен `null` или `undefined`.
- Про оператор нулевого слияния `??` спрашивают на технических интервью. Стоит повторно ознакомиться с данным
  материалом.

## <a id="trains">Тренировка</a>

## <a id="homework">Домашнее задание</a>

- Попробуйте написать реализацию операторов `!` и `!!`, применив известные инструменты, но не используя операторы `!`
  и `!!`.

## <a id="learn">Дополнительный материал</a>

- [Приоритет операторов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)